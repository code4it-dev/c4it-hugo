---
title: 'C# Tip: Access items from end using the ^ operator'
date: 2023-04-05
tags:
- CSharp
url: /csharptips/access-items-from-end
categories:
- CSharp Tips
summary: summary
---

Say that you you have an array of N items and you need to access an element counting from the end of the collection.

Usually, we tend to use the `Length` property of the array, and then subtract the number corresponding to the position we want to reach:

```cs
string[] values = {
    "alfa",
    "bravo",
    "charlie",
    "delta",
    "echo",
    "foxtrot",
    "golf"
};

var echo = values[values.Length - 3];
```

As you can see, we are accessing the same variable twice in a row: `values[values.Length - 3]`.

We can simplify that specific line of code by using the `^` operator:


```cs
string[] values = {
    "alfa",
    "bravo",
    "charlie",
    "delta",
    "echo",
    "foxtrot",
    "golf"
};

var echo = values[^3];
```

Yes, **that's just syntactic sugar**, but it can help making your code more readable. In fact, if you have a look at the IL code generated by both examples, they are perfectly identical.

Performance is not affected by this operator, so it's just a matter of readability.

Clearly, you still have to take care of array bounds - if you access `values[^55]` you'll get an `IndexOutOfRangeException`.

Pay attention that **the position is 1-based**!

```cs
string[] values = {
    "alfa",
    "bravo",
    "charlie",
    "delta",
    "echo",
    "foxtrot",
    "golf"
};

Console.WriteLine(values[^1]); //golf
Console.WriteLine(values[^0]); //IndexOutOfRangeException
```

## Further readings

To populate the lists in our Benchmarks we used `Enumerable.Range`. Do you know how it works? Have a look at this C# tip:

üîó [C# Tip: LINQ's Enumerable.Range to generate a sequence of consecutive numbers](https://www.code4it.dev/csharptips/enumerable-range)

*This article first appeared on [Code4IT üêß](https://www.code4it.dev/)*

## Wrapping up

In this article, we've learned that just a minimal change can impact our application performance.

We simply used a different constructor, but the difference is astounding. Clearly, this trick works only if already know the final length of the list (or, at least, an estimation). The more precise, the better!

I hope you enjoyed this article! Let's keep in touch on [Twitter](https://twitter.com/BelloneDavide) or on [LinkedIn](https://www.linkedin.com/in/BelloneDavide/), if you want! ü§úü§õ

Happy coding!

üêß
