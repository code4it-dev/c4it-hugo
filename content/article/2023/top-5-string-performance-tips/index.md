---
title: "Top 6 String Performance Tips"
date: 2023-12-15T11:48:29+01:00
url: /blog/post-slug
draft: false
categories:
 - Blog
tags:
 - CSharp
toc: true
summary: "A summary"
images:
 - /blog/post-slug/featuredImage.png
---

Sometimes, just a minor change makes a huge difference. Maybe you won't notice it when performing the operation a few times, but the improvement is significant when repeating the operation thousands of time.

In this article, we will learn five simple tricks to improve the performance of your application when dealing with strings.

Note: this article is part of [C# Advent Calendar 2023](https://csadvent.christmas/), organized by [Matthew D. Groves](https://twitter.com/mgroves): it's maybe the only Christmas tradition I like (yes, I'm kinda of a Grinch 😂).

## Solution setup

Before jumping to the benchmarks, I want to spend a few words on the tools I used for this article.

### Run benchmarks with BenchmarkDotNet

I'm using **BenchmarkDotNet** to create benchmarks of my code. BenchmarkDotNet is a library that runs your methods several times, captures some metrics, and generates a report of the executions. If you follow my blog, you might know that I've used it several times - for example, in my old article [Enum.HasFlag performance with BenchmarkDotNet](https://www.code4it.dev/blog/hasflag-performance-benchmarkdotnet/).

All the benchmarks I created follow the same structure:

```cs
[MemoryDiagnoser]
[Config(typeof(CsvConfig))]
public class BenchmarkName()
{
    [Params(1, 5, 10)]
    public int Size;

    public string[] AllStrings { get; set; }

    [IterationSetup]
    public void Setup()
    {
        AllStrings = StringArrayGenerator.Generate(Size, "hello!", "HELLO!");
    }

    [Benchmark(Baseline=true)]
    public void FirstMethod()
    {
        //omitted
    }

    [Benchmark]
    public void SecondMethod()
    {
        //omitted
    }
}
```

In short:

- the class is marked with the `[MemoryDiagnoser]` attribute: the benchmark will retrieve info for both time and memory usage;
- the class has the `[Config(typeof(CsvConfig))]` attribute: this attribute adds some custom configurations (see below) that help generating plots and diagrams;
- there is a property named `Size` with the attribute `[Params(1, 5, 10)]`: the `Params` attribute lists the possible values for the `Size` property;
- there is a method marked as `[IterationSetup]`: this method runs before every single execution, takes the value from the `Size` property, and initializes the `AllStrings` array;
- the methods that will be benchmarked are marked with the `[Benchmark]` attribute.

### Generating strings with Bogus

To generate dummy values I relied on **Bogus**: this library allows you to generate realistic values for your objects, with a great level of customizations.

The string array generation strategy is shared across all the benchmarks, so I moved it in a static method:

```cs
 public static class StringArrayGenerator
 {
     public static string[] Generate(int size, params string[] additionalStrings)
     {
         string[] array = new string[size];
         Faker faker = new Faker();

         List<string> fixedValues = [
             string.Empty,
             "   ",
             "\n  \t",
             null
         ];

         if (additionalStrings != null)
             fixedValues.AddRange(additionalStrings);

         for (int i = 0; i < array.Length; i++)
         {
             if (Random.Shared.Next() % 4 == 0)
             {
                 array[i] = Random.Shared.GetItems<string>(fixedValues.ToArray(), 1).First();
             }
             else
             {
                 array[i] = faker.Lorem.Word();
             }
         }

         return array;
     }
 }
```

Here I have a default set of predefined values (`[string.Empty, "   ", "\n  \t", null]`), which can be expanded with the values coming from the `additionalStrings` array, which are placed in random positions of the array.

In most cases, though, the value of the string is defined by Bogus.

### Generating plots with R and chartbenchmark.net

To generate the plots you will see in this article I relied on two methods.

The easiest one was using [chartbenchmark.net](https://chartbenchmark.net/): it's a fantastic tool created by [Carlos Villegas](https://github.com/yv989c) that transforms the output generated by BenchmarkDotNet on console in a dynamic, customizable plot.

We are ready. **It's time to run some benchmarks!**

## StringBuilder vs Concatenation

Let's start with a simple trick: if you need to concatenate strings, **using a StringBuilder is *generally* more efficient than concatenating string**.

```cs
[MemoryDiagnoser]
[Config(typeof(CsvConfig))]
public class StringBuilderVsConcatenation()
{
    [Params(4, 100, 10_000, 100_000)]
    public int Size;

    public string[] AllStrings { get; set; }

    [IterationSetup]
    public void Setup()
    {
        AllStrings = StringArrayGenerator.Generate(Size, "hello!", "HELLO!");
    }

    [Benchmark]
    public void WithStringBuilder()
    {
        StringBuilder sb = new StringBuilder();

        foreach (string s in AllStrings)
        {
            sb.Append(s);
        }

        var finalString = sb.ToString();
    }

    [Benchmark]
    public void WithConcatenation()
    {
        string finalString = "";
        foreach (string s in AllStrings)
        {
            finalString += s;
        }
    }
}
```

Every time you concatenate strings with the `+` sign you create a new instance of a `string`. This operation takes some time, and allocates memory for every operation.

On the contrary, using a `StringBuilder` object you can add the strings in memory and, using a performance-wise method, generate the final string.

Here's the result table:

| Method            | Size   | Mean             | Median           | Gen0         | Gen1         | Gen2         | Allocated     |
|------------------ |------- |-----------------:|-----------------:|-------------:|-------------:|-------------:|--------------:|
| WithStringBuilder | 4      |         5.149 us |         5.150 us |            - |            - |            - |        1008 B |
| WithConcatenation | 4      |         3.264 us |         3.300 us |            - |            - |            - |         840 B |
| WithStringBuilder | 100    |         6.778 us |         6.350 us |            - |            - |            - |        4352 B |
| WithConcatenation | 100    |        14.147 us |        14.600 us |            - |            - |            - |       43336 B |
| WithStringBuilder | 10000  |       106.790 us |       104.300 us |            - |            - |            - |      216392 B |
| WithConcatenation | 10000  |    75,890.430 us |    75,002.300 us |  279000.0000 |  230000.0000 |   39000.0000 |   465784152 B |
| WithStringBuilder | 100000 |     1,049.887 us |     1,046.900 us |            - |            - |            - |     2050920 B |
| WithConcatenation | 100000 | 7,760,510.914 us | 7,643,340.100 us | 2572000.0000 | 2520000.0000 | 2518000.0000 | 47114145576 B |

Let's see it as a plot.

**Beware of the scale in the diagram!**: it's a Log10 scale, so you'd better have a look at the value displayed on the Y axis.

![StringBuilder vs Concatenation benchmark](./stringbuilder-vs-concatenation.png)

As you can see, there is a considerable performance improvement.

There are some remarkable points:

1. When there are just a few strings to concatenate, the `+` operator is more performant, both on timing and allocated memory;
2. When you need to concatenate 100000 strings, the concatenation is **~7000 times slower** than the string builder.

As a conclusion: use the `StringBuilder` if you need to concatenate more than 5 or 6 strings. Use the string concatenation for smaller operations.

## EndsWith string vs char

One simple improvement can be done if you use `StartsWith` or `EndsWith` passing a single character.

There are two similar overloads: one that accepts a `string`, one that accepts a `char`.


```cs
[MemoryDiagnoser]
[Config(typeof(CsvConfig))]
public class EndsWithStringVsChar()
{
    [Params(100, 1000, 10_000, 100_000, 1_000_000)]
    public int Size;

    public string[] AllStrings { get; set; }

    [IterationSetup]
    public void Setup()
    {
        AllStrings = StringArrayGenerator.Generate(Size);
    }

    [Benchmark(Baseline = true)]
    public void EndsWithChar()
    {
    foreach (string s in AllStrings)
    {
        _ = s?.EndsWith('e');
    }
    }

    [Benchmark]
    public void EndsWithString()
    {
    foreach (string s in AllStrings)
    {
        _ = s?.EndsWith("e");
    }
    }
}
```

We have the following results:


| Method         | Size    | Mean         | Error       | StdDev      | Median       | Ratio |
|--------------- |-------- |-------------:|------------:|------------:|-------------:|------:|
| **EndsWithChar**   | 100     |     2.189 us |   0.2334 us |   0.6771 us |     2.150 us |  1.00 |
| **EndsWithString** | 100     |     5.228 us |   0.4495 us |   1.2970 us |     5.050 us |  2.56 |
|                |         |              |             |             |              |       |
| **EndsWithChar**   | 1000    |    12.796 us |   1.2006 us |   3.4831 us |    12.200 us |  1.00 |
| **EndsWithString** | 1000    |    30.434 us |   1.8783 us |   5.4492 us |    29.250 us |  2.52 |
|                |         |              |             |             |              |       |
| **EndsWithChar**   | 10000   |    25.462 us |   2.0451 us |   5.9658 us |    23.950 us |  1.00 |
| **EndsWithString** | 10000   |   251.483 us |  18.8300 us |  55.2252 us |   262.300 us | 10.48 |
|                |         |              |             |             |              |       |
| **EndsWithChar**   | 100000  |   209.776 us |  18.7782 us |  54.1793 us |   199.900 us |  1.00 |
| **EndsWithString** | 100000  |   826.090 us |  44.4127 us | 118.5465 us |   781.650 us |  4.14 |
|                |         |              |             |             |              |       |
| **EndsWithChar**   | 1000000 | 2,199.463 us |  74.4067 us | 217.0480 us | 2,190.600 us |  1.00 |
| **EndsWithString** | 1000000 | 7,506.450 us | 190.7587 us | 562.4562 us | 7,356.250 us |  3.45 |

Again, let's generate the plot using the **Log10** scale:

![EndsWith char vs EndsWith string](./endswith-char-vs-endswith-string.png)

They appear to be almost identical, but look closely: **based on this benchmark**, when we have 10000, using `EndsWith(string)` is 10x slower than `EndsWith(char)`. 

Also, here duration ratio on the 1.000.000-items array is ~3.5. At first I thought that there was an error on the benchmark, but when running it again on the benchmark, the ratio does not change.

Looks like you have the best improvement ratio when the array has ~10.000 items.

## IsNullOrEmpty vs IsNullOrEmpty + Trim vs IsNullOrWhitespace

As you might know, `string.IsNullOrWhiteSpace` performs stricter checks than `string.IsNullOrEmpty`.

Does it affect performance?

To demonstrate it, I have created three benchmarks: one for `string.IsNullOrEmpty`, one for `string.IsNullOrWhiteSpace`, and another one that lays in between: it first calls `Trim()` on the string, and then calls  `string.IsNullOrEmpty`.

```cs
[MemoryDiagnoser]
[Config(typeof(CsvConfig))]
public class StringEmptyBenchmark
{
    [Params(100, 1000, 10_000, 100_000, 1_000_000)]
    public int Size;

    public string[] AllStrings { get; set; }

    [IterationSetup]
    public void Setup()
    {
        AllStrings = StringArrayGenerator.Generate(Size);
    }

    [Benchmark(Baseline = true)]
    public void StringIsNullOrEmpty()
    {
        foreach (string s in AllStrings)
        {
            _ = string.IsNullOrEmpty(s);
        }
    }

    [Benchmark]
    public void StringIsNullOrEmptyWithTrim()
    {
        foreach (string s in AllStrings)
        {
            _ = string.IsNullOrEmpty(s?.Trim());
        }
    }

    [Benchmark]
    public void StringIsNullOrWhitespace()
    {
        foreach (string s in AllStrings)
        {
            _ = string.IsNullOrWhiteSpace(s);
        }
    }
}
```

We have the following values:


| Method                      | Size    | Mean         | Error       | StdDev      | Ratio |
|---------------------------- |-------- |-------------:|------------:|------------:|------:|
| **StringIsNullOrEmpty**         | 100     |     1.723 us |   0.2302 us |   0.6715 us |  1.00 |
| **StringIsNullOrEmptyWithTrim** | 100     |     2.394 us |   0.3525 us |   1.0282 us |  1.67 |
| **StringIsNullOrWhitespace**    | 100     |     2.017 us |   0.2289 us |   0.6604 us |  1.45 |
|                             |         |              |             |             |       |
| **StringIsNullOrEmpty**         | 1000    |    10.885 us |   1.3980 us |   4.0781 us |  1.00 |
| **StringIsNullOrEmptyWithTrim** | 1000    |    20.450 us |   1.9966 us |   5.8240 us |  2.13 |
| **StringIsNullOrWhitespace**    | 1000    |    13.160 us |   1.0851 us |   3.1482 us |  1.34 |
|                             |         |              |             |             |       |
| **StringIsNullOrEmpty**         | 10000   |    18.717 us |   1.1252 us |   3.2464 us |  1.00 |
| **StringIsNullOrEmptyWithTrim** | 10000   |    52.786 us |   1.2208 us |   3.5222 us |  2.90 |
| **StringIsNullOrWhitespace**    | 10000   |    46.602 us |   1.2363 us |   3.4668 us |  2.54 |
|                             |         |              |             |             |       |
| **StringIsNullOrEmpty**         | 100000  |   168.232 us |  12.6948 us |  36.0129 us |  1.00 |
| **StringIsNullOrEmptyWithTrim** | 100000  |   439.744 us |   9.3648 us |  25.3182 us |  2.71 |
| **StringIsNullOrWhitespace**    | 100000  |   394.310 us |   7.8976 us |  20.5270 us |  2.42 |
|                             |         |              |             |             |       |
| **StringIsNullOrEmpty**         | 1000000 | 2,074.234 us |  64.3964 us | 186.8257 us |  1.00 |
| **StringIsNullOrEmptyWithTrim** | 1000000 | 4,691.103 us | 112.2382 us | 327.4040 us |  2.28 |
| **StringIsNullOrWhitespace**    | 1000000 | 4,198.809 us |  83.6526 us | 161.1702 us |  2.04 |

As you can see from the Log10 table, the results are quite similar:

![IsNullOrEmpty vs IsNullOrWhiteSpace vs Trim](./string-isnullorempty-vs-trim-vs-isnullorwhitespace.png)

On average, `StringIsNullOrWhitespace` ~2 times slower than `StringIsNullOrEmpty`.

So, what should we do? Here's my two cents:

1. For all the data coming from the outside (passed as input to your system, received from an API call, read from the database), use `string.IsNUllOrWhiteSpace`: this way you can ensure that you are not receving unexpected data;
2. If you read data from an external API, customize your JSON deserializer to convert whitespace strings as empty values;
3. Needless to say it, choose the right method depending on the use case. If a string like "\n    \n   \t" is a valid value for you, use `string.IsNullOrEmpty`.

## ToUpper vs ToUpperInvariant vs ToLower vs ToLowerInvariant

Even though they look similar, there is a huge difference in terms of performance between these four methods.

```cs
[MemoryDiagnoser]
[Config(typeof(CsvConfig))]
public class ToUpperVsToLower()
{
    [Params(100, 1000, 10_000, 100_000, 1_000_000)]
    public int Size;

    public string[] AllStrings { get; set; }

    [IterationSetup]
    public void Setup()
    {
        AllStrings = StringArrayGenerator.Generate(Size);
    }

    [Benchmark]
    public void WithToUpper()
    {
        foreach (string s in AllStrings)
        {
            _ = s?.ToUpper();
        }
    }

    [Benchmark]
    public void WithToUpperInvariant()
    {
        foreach (string s in AllStrings)
        {
            _ = s?.ToUpperInvariant();
        }
    }

    [Benchmark]
    public void WithToLower()
    {
        foreach (string s in AllStrings)
        {
            _ = s?.ToLower();
        }
    }

    [Benchmark]
    public void WithToLowerInvariant()
    {
        foreach (string s in AllStrings)
        {
            _ = s?.ToLowerInvariant();
        }
    }
}
```

What will this benchmark generate?

| Method               | Size    | Mean          | Error       | StdDev       | Median        | P95           | Ratio |
|--------------------- |-------- |--------------:|------------:|-------------:|--------------:|--------------:|------:|
| WithToUpper          | 100     |      9.153 us |   0.9720 us |     2.789 us |      8.200 us |     14.980 us |  1.57 |
| WithToUpperInvariant | 100     |      6.572 us |   0.5650 us |     1.639 us |      6.200 us |      9.400 us |  1.14 |
| WithToLower          | 100     |      6.881 us |   0.5076 us |     1.489 us |      7.100 us |      9.220 us |  1.19 |
| WithToLowerInvariant | 100     |      6.143 us |   0.5212 us |     1.529 us |      6.100 us |      8.400 us |  1.00 |
|                      |         |               |             |              |               |               |       |
| WithToUpper          | 1000    |     69.776 us |   9.5416 us |    27.833 us |     68.650 us |    108.815 us |  2.60 |
| WithToUpperInvariant | 1000    |     51.284 us |   7.7945 us |    22.860 us |     38.700 us |     89.290 us |  1.85 |
| WithToLower          | 1000    |     49.520 us |   5.6085 us |    16.449 us |     48.100 us |     79.110 us |  1.85 |
| WithToLowerInvariant | 1000    |     27.000 us |   0.7370 us |     2.103 us |     26.850 us |     30.375 us |  1.00 |
|                      |         |               |             |              |               |               |       |
| WithToUpper          | 10000   |    241.221 us |   4.0480 us |     3.588 us |    240.900 us |    246.560 us |  1.68 |
| WithToUpperInvariant | 10000   |    339.370 us |  42.4036 us |   125.028 us |    381.950 us |    594.760 us |  1.48 |
| WithToLower          | 10000   |    246.861 us |  15.7924 us |    45.565 us |    257.250 us |    302.875 us |  1.12 |
| WithToLowerInvariant | 10000   |    143.529 us |   2.1542 us |     1.910 us |    143.500 us |    146.105 us |  1.00 |
|                      |         |               |             |              |               |               |       |
| WithToUpper          | 100000  |  2,165.838 us |  84.7013 us |   223.137 us |  2,118.900 us |  2,875.800 us |  1.66 |
| WithToUpperInvariant | 100000  |  1,885.329 us |  36.8408 us |    63.548 us |  1,894.500 us |  1,967.020 us |  1.41 |
| WithToLower          | 100000  |  1,478.696 us |  23.7192 us |    50.547 us |  1,472.100 us |  1,571.330 us |  1.10 |
| WithToLowerInvariant | 100000  |  1,335.950 us |  18.2716 us |    35.203 us |  1,330.100 us |  1,404.175 us |  1.00 |
|                      |         |               |             |              |               |               |       |
| WithToUpper          | 1000000 | 20,936.247 us | 414.7538 us | 1,163.014 us | 20,905.150 us | 22,928.350 us |  1.64 |
| WithToUpperInvariant | 1000000 | 19,056.983 us | 368.7473 us |   287.894 us | 19,085.400 us | 19,422.880 us |  1.41 |
| WithToLower          | 1000000 | 14,266.714 us | 204.2906 us |   181.098 us | 14,236.500 us | 14,593.035 us |  1.06 |
| WithToLowerInvariant | 1000000 | 13,464.127 us | 266.7547 us |   327.599 us | 13,511.450 us | 13,926.495 us |  1.00 |

Let's see it as the usual Log10 plot:

![ToUpper vs ToLower](./toUpper-vs-toLower.png)

We can notice a few points:

1. The ToUpper family is generally slower than the ToLowerFamily;
2. The Invariant family is faster than the non-Invariant; we will see more below;

So, if you have to normalize strings by using the same casing, `ToLowerInvariant` is the best choice.

## OrdinalIgnoreCase vs InvariantCultureIgnoreCase 

Comparing strings is trivial: the `string.Compare` method is all you need.

There are several ways to compare string: you can specify the comparison rules by setting the `comparisonType` parameter, which accepts a `StringComparison` value.

```cs
[MemoryDiagnoser]
[Config(typeof(CsvConfig))]
public class StringCompareOrdinalVsInvariant()
{
    [Params(100, 1000, 10_000, 100_000, 1_000_000)]
    public int Size;

    public string[] AllStrings { get; set; }

    [IterationSetup]
    public void Setup()
    {
        AllStrings = StringArrayGenerator.Generate(Size, "hello!", "HELLO!");
    }

    [Benchmark(Baseline = true)]
    public void WithOrdinalIgnoreCase()
    {
        foreach (string s in AllStrings)
        {
            _ = string.Equals(s, "hello!", StringComparison.OrdinalIgnoreCase);
        }
    }

    [Benchmark]
    public void WithInvariantCultureIgnoreCase()
    {
        foreach (string s in AllStrings)
        {
            _ = string.Equals(s, "hello!", StringComparison.InvariantCultureIgnoreCase);
        }
    }
}
```

Let's see the results:

| Method                         | Size    | Mean          | Error       | StdDev      | Ratio |
|------------------------------- |-------- |--------------:|------------:|------------:|------:|
| WithOrdinalIgnoreCase          | 100     |      2.380 us |   0.2856 us |   0.8420 us |  1.00 |
| WithInvariantCultureIgnoreCase | 100     |      7.974 us |   0.7817 us |   2.3049 us |  3.68 |
|                                |         |               |             |             |       |
| WithOrdinalIgnoreCase          | 1000    |     11.316 us |   0.9170 us |   2.6603 us |  1.00 |
| WithInvariantCultureIgnoreCase | 1000    |     35.265 us |   1.5455 us |   4.4591 us |  3.26 |
|                                |         |               |             |             |       |
| WithOrdinalIgnoreCase          | 10000   |     20.262 us |   1.1801 us |   3.3668 us |  1.00 |
| WithInvariantCultureIgnoreCase | 10000   |    225.892 us |   4.4945 us |  12.5289 us | 11.41 |
|                                |         |               |             |             |       |
| WithOrdinalIgnoreCase          | 100000  |    148.270 us |  11.3234 us |  32.8514 us |  1.00 |
| WithInvariantCultureIgnoreCase | 100000  |  1,811.144 us |  35.9101 us |  64.7533 us | 12.62 |
|                                |         |               |             |             |       |
| WithOrdinalIgnoreCase          | 1000000 |  2,050.894 us |  59.5966 us | 173.8460 us |  1.00 |
| WithInvariantCultureIgnoreCase | 1000000 | 18,138.063 us | 360.1967 us | 986.0327 us |  8.87 |

As you can see, there's a HUGE difference between Ordinal and Invariant.

When dealing with 100.000 items, `StringComparison.InvariantCultureIgnoreCase` is **12 times slower** than `StringComparison.OrdinalIgnoreCase`!

![Ordinal vs Invariant culture](./ordinal-vs-invariant.png)

Why? Also, why should we use one instead of the other?

Have a look at this code snippet:

```cs
var s1 = "Aa";
var s2 = "A" + new string('\u0000', 3) + "a";

string.Equals(s1, s2, StringComparison.InvariantCultureIgnoreCase); //True
string.Equals(s1, s2, StringComparison.OrdinalIgnoreCase); //False
```

As you can see, `s1` and `s2` represent **equivalent, but not equal, strings**. We can then deduce that `OrdinalIgnoreCase` checks for the exact values of the characters, while `InvariantCultureIgnoreCase` check the *"meaning"* of the string.

So, in most cases, you might want to use `OrdinalIgnoreCase` (as always, it depends on your use case!)

## Newtonsoft vs System.Text.Json

For the last benchmark I created the exact same model used [as an example](https://github.com/bchavez/Bogus/blob/master/Examples/GettingStarted/Program.cs) in the offical documentation.

The purpose of this benchmark is to see which JSON serialization library is faster: Newtonsoft or System.Text.Json?

```cs
[MemoryDiagnoser]
[Config(typeof(CsvConfig))]
public class JsonSerializerComparison
{
    [Params(100, 10_000, 1_000_000)]
    public int Size;
    List<User?> Users { get; set; }

    [IterationSetup]
    public void Setup()
    {
        Users = UsersCreator.GenerateUsers(Size);
    }

    [Benchmark(Baseline = true)]
    public void WithJson()
    {
        foreach (User? user in Users)
        {
            var asString = System.Text.Json.JsonSerializer.Serialize(user);

            _ = System.Text.Json.JsonSerializer.Deserialize<User?>(asString);
        }
    }

    [Benchmark]
    public void WithNewtonsoft()
    {
        foreach (User? user in Users)
        {
            string asString = Newtonsoft.Json.JsonConvert.SerializeObject(user);
            _ = Newtonsoft.Json.JsonConvert.DeserializeObject<User?>(asString);
        }
    }
}
```

As you might know, the .NET team has added lots of performance improvements to the JSON Serialization functionalities, and you can really see the difference!

| Method         | Size    | Mean         | Error       | StdDev      | Median       | Ratio | RatioSD | Gen0         | Gen1      | Allocated     | Alloc Ratio |
|--------------- |-------- |-------------:|------------:|------------:|-------------:|------:|--------:|-------------:|----------:|--------------:|------------:|
| WithJson       | 100     |     2.063 ms |   0.1409 ms |   0.3927 ms |     1.924 ms |  1.00 |    0.00 |            - |         - |     292.87 KB |        1.00 |
| WithNewtonsoft | 100     |     4.452 ms |   0.1185 ms |   0.3243 ms |     4.391 ms |  2.21 |    0.39 |            - |         - |     882.71 KB |        3.01 |
|                |         |              |             |             |              |       |         |              |           |               |             |
| WithJson       | 10000   |    44.237 ms |   0.8787 ms |   1.3936 ms |    43.873 ms |  1.00 |    0.00 |    4000.0000 | 1000.0000 |   29374.98 KB |        1.00 |
| WithNewtonsoft | 10000   |    78.661 ms |   1.3542 ms |   2.6090 ms |    78.865 ms |  1.77 |    0.08 |   14000.0000 | 1000.0000 |   88440.99 KB |        3.01 |
|                |         |              |             |             |              |       |         |              |           |               |             |
| WithJson       | 1000000 | 4,233.583 ms |  82.5804 ms | 113.0369 ms | 4,202.359 ms |  1.00 |    0.00 |  484000.0000 | 1000.0000 | 2965741.56 KB |        1.00 |
| WithNewtonsoft | 1000000 | 5,260.680 ms | 101.6941 ms | 108.8116 ms | 5,219.955 ms |  1.24 |    0.04 | 1448000.0000 | 1000.0000 |  8872031.8 KB |        2.99 |


As you can see, Newtonsoft is 2x slower than System.Text.Json, and it allocates 3x the memory, compared with the other library.

So, well, if you don't use library-specific functionalities, I suggest you replacing *Newtonsoft* with *System.Text.Json*.

## Further readings

_This article first appeared on [Code4IT 🐧](https://www.code4it.dev/)_


## Wrapping up


I hope you enjoyed this article! Let's keep in touch on [Twitter](https://twitter.com/BelloneDavide) or [LinkedIn](https://www.linkedin.com/in/BelloneDavide/)! 🤜🤛

Happy coding!

🐧


[ ] Titoli
[ ] Frontmatter
[ ] Rinomina immagini
[ ] Alt Text per immagini
[ ] Grammatica
[ ] Bold/Italics
[ ] Nome cartella e slug devono combaciare
[ ] Immagine di copertina
[ ] Pulizia formattazione
[ ] Metti la giusta OgTitle
[ ] Fai resize della immagine di copertina
[ ] Le immagini PNG hanno tutte lo sfondo trasparente. Metti lo sfondi bianco
[ ] rilancia benchmark stringbuilder mettendo baseline. sostituisci tabella e immagine